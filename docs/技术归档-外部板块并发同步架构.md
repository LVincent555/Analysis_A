# 外部板块并发同步架构 - 技术归档

**创建时间**: 2025-12-10  
**模块位置**: `backend/scripts/sync_ext_boards.py`  
**状态**: ✅ 生产级稳定

---

## 📌 项目背景

### 需求
从东方财富同步 527 个板块（86 行业 + 441 概念）的成分股数据，约 60,000+ 条记录。

### 约束条件
- 代理 IP：91HTTP 隧道代理，最大 200 IP/天
- 代理商 QPS 限制：约 0.5 次/秒
- 单 IP 有效期：60 秒
- 目标：100% 数据完整性

---

## 🏗️ 架构设计

### 最终方案：死磕模式（单队列 + 重试计数）

```
┌─────────────────────────────────────────────────────────────┐
│                     Manager-Worker 架构                      │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   ┌──────────────┐                                          │
│   │   主线程      │  监控 + 数据校验 + 写库 + 进度条         │
│   │  (Manager)   │                                          │
│   └──────┬───────┘                                          │
│          │                                                   │
│          ▼                                                   │
│   ┌──────────────────────────────────────────┐              │
│   │         单任务队列（无限轮回）              │              │
│   │  (retry_count, board_id, board_name)     │              │
│   └──────────────────────────────────────────┘              │
│          │                                                   │
│          ▼                                                   │
│   ┌──────┬──────┬──────┬──────┬──────┬──────┐               │
│   │  W0  │  W1  │  W2  │  W3  │  W4  │  W5  │  6 Worker    │
│   └──────┴──────┴──────┴──────┴──────┴──────┘               │
│          │                                                   │
│          ▼                                                   │
│   ┌──────────────────────────────────────────┐              │
│   │       ProxyManager（智能冷却）            │              │
│   │  - 2秒强制间隔（漏桶算法）                 │              │
│   │  - mark_failed() 标记烂 IP                │              │
│   └──────────────────────────────────────────┘              │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

---

## 🔧 核心技术难点与解决方案

### 1. 利特尔定律（Little's Law）计算最佳线程数

**问题**：多少线程才能平衡 IP 供给与消耗？

**数学建模**：
```
供给端 (Supply)：代理商 QPS ≈ 0.5 次/秒
需求端 (Demand)：N 个线程，每线程每 50 秒换一次 IP

平衡公式：0.5 ≥ N/50 → N ≤ 25

考虑 3~4 倍安全冗余：N_safe = 25/4 ≈ 6
```

**结论**：**6 线程**是黄金分割点

---

### 2. 代理商接口限流（智能冷却机制）

**问题**：多线程同时请求代理 IP，触发代理商 QPS 限制

**解决方案**：漏桶算法简化版
```python
# ProxyManager._fetch_new_proxy()
MIN_INTERVAL = 2.0  # 强制冷却间隔

with self._lock:
    now = time.time()
    elapsed = now - self._last_fetch_time
    if elapsed < MIN_INTERVAL:
        time.sleep(MIN_INTERVAL - elapsed)
    self._last_fetch_time = time.time()
    # ... 执行实际请求
```

---

### 3. 线程共振效应（防共振优化）

**问题**：所有线程同时启动 + 相同 TTL → 同时换 IP → 触发限流

**解决方案**：
```python
# 1. 错峰启动
time.sleep(random.uniform(0, 5))

# 2. 随机 TTL（±5秒抖动）
current_ttl = ip_ttl + random.uniform(-5, 5)

# 3. 请求前随机延迟
time.sleep(random.uniform(req_delay_min, req_delay_max))
```

---

### 4. 僵尸 IP 循环 Bug（核心修复）

**问题**：IP 失效后，Worker 销毁 session，但 ProxyManager 仍返回同一个烂 IP（缓存未清除）

**症状**：
- 失败次数极高（60+）
- IP 消耗极低（14 个）
- 任务疯狂重试但始终失败

**根因分析**：
```
T1 拿到 IP_A → 请求失败 → session = None
T1 请求新 IP → ProxyManager: "IP_A 还没过期，继续用"
T1 拿回同一个烂 IP → 再次失败 → 循环...
```

**解决方案**：显式标记 IP 失效
```python
# 失败时调用 mark_failed() 删除缓存
if error_type in ('timeout', 'connection', 'invalid_json', 'unknown', 'empty_data'):
    if session:
        session.close()
    session = None
    
    # 【核心修复】告诉 ProxyManager 删除这个烂 IP
    if proxy_mgr:
        proxy_mgr.mark_failed()
```

---

### 5. 统一错误处理（集中处理所有异常）

**问题**：`NoneType` object has no attribute 'get' 错误分散在各处

**解决方案**：封装统一请求函数
```python
def fetch_board_members(session, board_name: str) -> dict:
    """
    返回: {'ok': bool, 'data': list, 'error': str, 'error_type': str}
    """
    # 安全解析 JSON
    try:
        j = resp.json()
    except ValueError:
        return {'ok': False, 'error': 'JSON解析失败', 'error_type': 'invalid_json'}
    
    # 安全访问字段
    data = j.get("data")
    if not data:
        return {'ok': False, 'error': '返回数据为空', 'error_type': 'empty_data'}
    
    # ... 成功返回
    return {'ok': True, 'data': all_records, 'error': None, 'error_type': None}
```

**错误分类**：
| error_type | 说明 | 是否换 IP |
|------------|------|----------|
| timeout | 请求超时 | ✅ |
| connection | 连接错误 | ✅ |
| invalid_json | JSON 解析失败 | ✅ |
| empty_data | 返回数据为空 | ✅ |
| no_code | 无板块代码 | ❌ |
| init_error | 映射表未初始化 | ❌ |

---

### 6. 单队列 + 重试计数（取代多级队列）

**问题**：之前的"二级队列补考"架构复杂，效率低

**解决方案**：单队列 + 重试计数
```python
# 任务结构：(retry_count, board_id, board_name)
task_queue.put((0, b_id, b_name))  # 初始重试次数为 0

# 失败时回炉
if retry_count >= MAX_RETRY:
    # 彻底放弃
    result_queue.put({'type': 'FAIL_PERM', ...})
else:
    # 重试次数 +1，放回队列尾部
    task_queue.put((retry_count + 1, board_id, board_name))
```

**优势**：
- 逻辑清晰：一个队列，一套规则
- 公平调度：失败任务放到队尾，给其他线程机会
- 可控重试：最多 10 次，避免无限循环

---

## 📊 最终效果

### 运行参数
```bash
python backend/scripts/sync_ext_boards.py \
  --provider em --proxy --concurrent \
  --workers 6 --max-ips 200 --ip-ttl 45 \
  --req-delay-min 1.0 --req-delay-max 2.0 --force
```

### 同步结果
| 指标 | 行业板块 | 概念板块 | 总计 |
|------|---------|---------|------|
| 成功率 | **86/86 (100%)** | **441/441 (100%)** | **527/527** |
| 永久失败 | 0 | 0 | **0** |
| 成分股 | 5,450 | 55,756 | **61,206** |
| IP 消耗 | 15 | 97 | **97/200** |
| 耗时 | - | - | **6.7 分钟** |

### 错误统计（全部重试成功）
- connection: 75 次 → 换 IP 后成功
- timeout: 1 次 → 换 IP 后成功

---

## 🔑 关键参数说明

| 参数 | 默认值 | 说明 |
|------|--------|------|
| `--workers` | 6 | 并发线程数（利特尔定律计算） |
| `--ip-ttl` | 45 | IP 复用时间（秒），留 15s 缓冲 |
| `--req-delay-min` | 1.0 | 请求前最小延迟（秒） |
| `--req-delay-max` | 2.0 | 请求前最大延迟（秒） |
| `--max-ips` | 200 | 最大 IP 配额 |
| `MAX_RETRY` | 10 | 单任务最大重试次数 |
| `MIN_INTERVAL` | 2.0 | 代理获取最小间隔（智能冷却） |

---

## 📁 相关文件

- `backend/scripts/sync_ext_boards.py` - 主同步脚本
- `data/ext_board_sync_state.json` - 同步状态记录

---

## 📝 经验总结

1. **数学先行**：利特尔定律帮助计算最佳并发数，避免盲目调参
2. **防共振**：多线程 + 共享资源必须考虑错峰机制
3. **显式失效**：缓存系统必须有主动失效机制，不能只靠 TTL
4. **统一错误处理**：集中处理所有异常，分类统计，便于定位问题
5. **单队列循环**：比多级队列更简单、更可靠

---

**文档状态**: 完成  
**最后更新**: 2025-12-10
