# 系统管理模块改进实施计划

> **版本**: v2.2.1 (Final Polish)  
> **日期**: 2025-12-23  
> **状态**: **待执行 (Ready)**  
> **变更**: 在 v2.2 基础上增强了 Key 一致性约束、按 Key 限频告警和 ORM 严谨性。

---

## 1. 核心架构变更

### 1.1 缓存策略修正（Critical）

| 分区 | 原策略 (v2.0) | **修正后策略** | 原因 |
|------|---------------|----------------|------|
| `config` | Cache-Aside | **Write-Through (TTL=0)** | Cache-Aside 的 `set` 是删除缓存；预热必须使用 Write-Through 才能真正写入内存 |

### 1.2 Phase 0 改动清单

| 改动项 | 涉及文件 | 关键动作 |
|--------|----------|----------|
| **分区注册** | `app/main.py` | 注册 `config` 分区时使用 `WriteThroughPolicy(ttl=0)` |
| **预热增强** | `app/core/caching/facade.py` | `reload_configs` 增加 JSON 解析 + 异常隔离 + 错误汇总日志 |
| **Key 一致性** | `app/core/caching/facade.py` | `get_config` 内部强制使用 `KeyBuilder.config(key)` |
| **策略引擎** | `app/services/policy_engine.py` | **完全无状态**，Miss 时**按 Key 限频**告警 |
| **配置更新** | `app/routers/admin.py` | 记录 `old`→`new` 审计日志；更新后强制 Reload |
| **Auth 改造** | `app/routers/auth.py` | **先 locked_until 后 verify_password**；接入动态 Token TTL |

---

## 2. 代码实现规范

### 2.1 修正分区注册 (`main.py`)

```python
@asynccontextmanager
async def lifespan(app: FastAPI):
    # ... 其他分区注册 ...

    # [修正] Config 分区改用 Write-Through (TTL=0 表示永不过期)
    from app.core.caching.policies import WriteThroughPolicy
    UnifiedCache.register(
        "config",
        ObjectStore("config", WriteThroughPolicy(ttl=0))
    )
    
    # [启动预热]
    from app.core.caching import cache
    db = SessionLocal()
    try:
        cache.reload_configs(db)
        logger.info("System configs preloaded (Write-Through)")
    finally:
        db.close()
    
    yield
```

### 2.2 PublicCache 增强 (`facade.py`)

```python
@staticmethod
def get_config(key: str, default: Any = None) -> Any:
    """
    [v2.2.1] 获取配置
    - 强制使用 KeyBuilder 封装 Key，确保与 reload_configs 一致
    """
    real_key = KeyBuilder.config(key)  # 裸 Key -> Real Key
    val = UnifiedCache.config().get(real_key)
    return val if val is not None else default

@staticmethod
def reload_configs(db_session):
    """
    [v2.2.1] 全量刷新配置缓存
    - 错误日志携带具体异常信息
    - 结束后打印失败汇总
    """
    from app.db_models import SystemConfig
    import json
    
    configs = db_session.query(SystemConfig).all()
    config_store = UnifiedCache.config()
    
    loaded, errors = 0, []
    
    for c in configs:
        try:
            real_key = KeyBuilder.config(c.config_key)
            val = c.config_value
            
            if c.config_type == 'int':
                val = int(val)
            elif c.config_type == 'bool':
                val = str(val).lower() in ('true', '1', 'yes')
            elif c.config_type == 'json':
                val = json.loads(val)
            
            config_store.set(real_key, val)
            loaded += 1
        except Exception as e:
            error_msg = f"Key={c.config_key} Error={str(e)}"
            errors.append(error_msg)
            logger.error(f"[ConfigReload] Parse Error: {error_msg}")

    logger.info(f"[ConfigReload] Success: {loaded}/{len(configs)}")
    if errors:
        logger.warning(f"[ConfigReload] Failed ({len(errors)}): {errors}")
```

### 2.3 PolicyEngine（完全无状态 + 按 Key 限频）

```python
import logging
import time
from app.core.caching import cache

# 按 Key 记录上次告警时间，防止日志刷屏
_last_miss_log = {}

class PolicyEngine:
    """策略引擎 v2.2.1 - 无状态，不持有 _cache"""

    @staticmethod
    def _cfg(key: str, default=None):
        val = cache.get_config(key)
        
        if val is None:
            # [v2.2.1] 按 Key 限频告警（每分钟同 Key 只报一次）
            now = time.time()
            last_time = _last_miss_log.get(key, 0)
            
            if now - last_time > 60:
                logger.warning(f"[PolicyEngine] MISS '{key}', using default='{default}'. Check preload.")
                _last_miss_log[key] = now
            
            return default
        return val

    @classmethod
    def get_login_policy(cls) -> dict:
        return {
            "max_attempts": int(cls._cfg("login_max_attempts", 5)),
            "lockout_minutes": int(cls._cfg("login_lockout_minutes", 30)),
        }
    
    @classmethod
    def get_session_policy(cls, user) -> dict:
        global_max = int(cls._cfg("session_max_devices", 3))
        user_max = user.allowed_devices if (user.allowed_devices or 0) > 0 else None
        return {
            "max_devices": user_max or global_max,
            "access_token_hours": int(cls._cfg("session_access_token_hours", 24)),
            "refresh_token_days": int(cls._cfg("session_refresh_token_days", 7)),
        }
    
    @classmethod
    def validate_password(cls, password: str):
        min_len = int(cls._cfg("password_min_length", 6))
        if len(password) < min_len:
            raise ValueError(f"密码长度不能少于 {min_len} 位")
```

### 2.4 配置更新接口（审计增强 + ORM 严谨）

```python
@router.put("/admin/configs")
async def update_configs(configs: List[ConfigUpdate], db: Session = Depends(get_db)):
    import json
    
    # 1. 查询旧值（增加 .all() 确保立即执行）
    keys = [c.key for c in configs]
    old_configs = db.query(SystemConfig).filter(SystemConfig.config_key.in_(keys)).all()
    old_map = {c.config_key: c.config_value for c in old_configs}
    
    changes = []
    
    # 2. 更新数据库
    for cfg in configs:
        old_val = old_map.get(cfg.key)
        if old_val != cfg.value:
            db.query(SystemConfig).filter_by(config_key=cfg.key).update({
                "config_value": cfg.value,
                "updated_at": datetime.utcnow()
            })
            changes.append({"key": cfg.key, "old": old_val, "new": cfg.value})
    db.commit()
    
    # 3. 刷新缓存
    cache.reload_configs(db)
    
    # 4. 审计日志（结构化 old→new）
    if changes:
        log_service.record(
            action="config_update",
            detail=json.dumps(changes, ensure_ascii=False)
        )
```

---

## 3. 策略决议规则

| 策略项 | 全局 Key | 决议逻辑 | Phase 0 状态 |
|--------|----------|----------|--------------|
| **最大设备数** | `session_max_devices` | User > 0 覆盖 Global | ✅ 生效 |
| **登录锁定** | `login_max_attempts` | 全局统一 | ✅ 生效 |
| **Token有效期** | `session_access_token_hours` | 全局统一 | ✅ 生效 |
| **密码强度** | `password_min_length` | 全局统一 | ✅ 生效 |
| **失败重置** | `login_attempt_reset_minutes` | — | ❌ 暂不生效 |
| **验证码** | `captcha_enabled` | — | ❌ 暂不生效 |

---

## 4. 风险控制

1. **缓存策略冲突**：必须确认 `config` 分区使用 `WriteThroughPolicy`，绝不能用 Cache-Aside
2. **默认值静默**：关注日志中 `[PolicyEngine] MISS` 出现频率，正常应为 0；**限频按 Key 维度**
3. **Key 一致性**：`get_config` 和 `reload_configs` 必须都使用 `KeyBuilder.config(key)` 封装
4. **单进程约束**：服务端必须 `workers=1`，否则配置更新不会跨进程同步
5. **锁定逻辑顺序**：Auth 流程必须遵循 **"先查 `locked_until` → 后验密码"**；若已锁定，**严禁**继续验证密码或累加 `failed_attempts`

---

## 5. 验收标准

| # | 验收项 | 测试方法 |
|---|--------|----------|
| 1 | 修改 `login_max_attempts` 后立即生效 | 改配置 → 连续输错密码 → 验证锁定次数 |
| 2 | 修改 `session_access_token_hours` 后新Token过期时间变化 | 改配置 → 登录 → 检查JWT exp |
| 3 | 密码策略生效 | `password_min_length=8` → 注册6位密码 → 400 |
| 4 | 审计日志记录 old→new | 改配置 → 查 operation_logs |
| 5 | 启动无 MISS 告警 | 启动后日志无 `[PolicyEngine] MISS` |

---

## 6. 预估工时

| Phase | 工作内容 | 预估 |
|-------|----------|------|
| Phase 0 | 分区策略修正 + PolicyEngine + Auth 改造 | 4-6h |
| Phase 1 | 文档补充 + 测试 | 2h |
| Phase 2 | 前端菜单调整 | 2h |
| **合计** | | **8-10h** |

---

*文档更新时间: 2025-12-23 (v2.2.1 Final)*
