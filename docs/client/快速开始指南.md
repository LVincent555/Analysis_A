# 快速开始指南

> 本文档帮助你快速启动客户端开发

---

## 一、开发顺序

```
推荐开发顺序：

1. 后端认证模块 (3h)
   ├── User表迁移
   ├── JWT认证
   └── 登录API

2. 后端加密模块 (3h)
   ├── AES加解密工具
   ├── 加密网关中间件
   └── 路由注册

3. 前端客户端基础 (3h)
   ├── 创建frontend-client
   ├── Electron配置
   └── 登录页面

4. 前端加密层 (2h)
   ├── AES加密工具
   └── 改造API服务

5. 联调测试 (2h)
```

---

## 二、第一步：后端认证模块

### 2.1 创建目录结构

```bash
cd backend/app
mkdir -p auth crypto middleware
```

### 2.2 创建文件

**auth/__init__.py**
```python
from .jwt_handler import create_access_token, verify_token
from .password import hash_password, verify_password
from .dependencies import get_current_user
```

**auth/password.py**
```python
import bcrypt

def hash_password(password: str) -> str:
    return bcrypt.hashpw(password.encode(), bcrypt.gensalt()).decode()

def verify_password(password: str, hashed: str) -> bool:
    return bcrypt.checkpw(password.encode(), hashed.encode())
```

**auth/jwt_handler.py**
```python
from datetime import datetime, timedelta
from jose import jwt, JWTError
import os

SECRET_KEY = os.getenv("JWT_SECRET_KEY", "your-secret-key-change-in-production")
ALGORITHM = "HS256"

def create_access_token(user_id: int, expires_hours: int = 24) -> str:
    expire = datetime.utcnow() + timedelta(hours=expires_hours)
    payload = {"sub": str(user_id), "exp": expire}
    return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)

def verify_token(token: str) -> dict | None:
    try:
        return jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
    except JWTError:
        return None
```

**auth/dependencies.py**
```python
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.orm import Session
from ..database import get_db
from ..db_models import User
from .jwt_handler import verify_token

security = HTTPBearer()

async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: Session = Depends(get_db)
) -> User:
    token = credentials.credentials
    payload = verify_token(token)
    
    if not payload:
        raise HTTPException(status_code=401, detail="无效的Token")
    
    user_id = int(payload.get("sub"))
    user = db.query(User).filter(User.id == user_id).first()
    
    if not user or not user.is_active:
        raise HTTPException(status_code=401, detail="用户不存在或已禁用")
    
    return user
```

### 2.3 添加User模型

在 `db_models.py` 末尾添加：

```python
class User(Base):
    """用户表"""
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    username = Column(String(50), unique=True, nullable=False)
    password_hash = Column(String(255), nullable=False)
    user_key_encrypted = Column(String(255), nullable=False)
    role = Column(String(20), default='user')
    is_active = Column(Boolean, default=True)
    created_at = Column(TIMESTAMP, default=datetime.utcnow)
    last_login = Column(TIMESTAMP)
    offline_enabled = Column(Boolean, default=True)
    offline_days = Column(Integer, default=7)
```

### 2.4 创建登录路由

**routers/auth.py**
```python
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from pydantic import BaseModel
from datetime import datetime
import os
import base64

from ..database import get_db
from ..db_models import User
from ..auth.password import hash_password, verify_password
from ..auth.jwt_handler import create_access_token
from ..crypto.aes_handler import AESCrypto

router = APIRouter(prefix="/api/auth", tags=["auth"])

# 主密钥（从环境变量读取）
MASTER_KEY = base64.b64decode(os.getenv("MASTER_KEY", base64.b64encode(os.urandom(32)).decode()))

class LoginRequest(BaseModel):
    username: str
    password: str
    device_id: str = "default"

class RegisterRequest(BaseModel):
    username: str
    password: str

@router.post("/register")
async def register(req: RegisterRequest, db: Session = Depends(get_db)):
    """注册新用户"""
    # 检查用户名是否存在
    if db.query(User).filter(User.username == req.username).first():
        raise HTTPException(400, "用户名已存在")
    
    # 生成用户密钥
    user_key = os.urandom(32)
    master_crypto = AESCrypto(MASTER_KEY)
    user_key_encrypted = master_crypto.encrypt({"key": base64.b64encode(user_key).decode()})
    
    # 创建用户
    user = User(
        username=req.username,
        password_hash=hash_password(req.password),
        user_key_encrypted=user_key_encrypted
    )
    db.add(user)
    db.commit()
    
    return {"success": True, "message": "注册成功"}

@router.post("/login")
async def login(req: LoginRequest, db: Session = Depends(get_db)):
    """用户登录"""
    user = db.query(User).filter(User.username == req.username).first()
    
    if not user or not verify_password(req.password, user.password_hash):
        raise HTTPException(401, "用户名或密码错误")
    
    if not user.is_active:
        raise HTTPException(403, "账户已禁用")
    
    # 生成会话密钥
    session_key = os.urandom(32)
    
    # 解密用户密钥
    master_crypto = AESCrypto(MASTER_KEY)
    user_key_data = master_crypto.decrypt(user.user_key_encrypted)
    user_key = base64.b64decode(user_key_data["key"])
    
    # 用用户密钥加密会话密钥
    user_crypto = AESCrypto(user_key)
    session_key_encrypted = user_crypto.encrypt({"key": base64.b64encode(session_key).decode()})
    
    # 生成Token
    token = create_access_token(user.id)
    
    # 更新最后登录时间
    user.last_login = datetime.utcnow()
    db.commit()
    
    # TODO: 存储session_key到Redis或内存缓存，关联user_id
    # 这里简化处理，直接返回
    
    return {
        "token": token,
        "session_key": session_key_encrypted,
        "user": {
            "id": user.id,
            "username": user.username,
            "role": user.role
        }
    }
```

### 2.5 注册路由

在 `main.py` 中添加：

```python
from .routers.auth import router as auth_router

# 在其他router注册之后添加
app.include_router(auth_router)
```

---

## 三、第二步：后端加密模块

### 3.1 AES加密工具

**crypto/__init__.py**
```python
from .aes_handler import AESCrypto
```

**crypto/aes_handler.py**
```python
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
import os
import base64
import json

class AESCrypto:
    def __init__(self, key: bytes):
        if len(key) != 32:
            raise ValueError("密钥必须是32字节")
        self.gcm = AESGCM(key)
    
    def encrypt(self, data: dict) -> str:
        plaintext = json.dumps(data, ensure_ascii=False).encode('utf-8')
        nonce = os.urandom(12)
        ciphertext = self.gcm.encrypt(nonce, plaintext, None)
        return base64.b64encode(nonce + ciphertext).decode('utf-8')
    
    def decrypt(self, encrypted: str) -> dict:
        raw = base64.b64decode(encrypted)
        nonce, ciphertext = raw[:12], raw[12:]
        plaintext = self.gcm.decrypt(nonce, ciphertext, None)
        return json.loads(plaintext.decode('utf-8'))
```

---

## 四、第三步：创建前端客户端

### 4.1 复制项目

```bash
cd stock_analysis_app
xcopy /E /I frontend frontend-client
cd frontend-client
```

### 4.2 安装依赖

```bash
npm install --save-dev electron electron-builder electron-is-dev concurrently wait-on
npm install electron-updater crypto-js
```

### 4.3 创建Electron文件

**electron/main.js**
```javascript
const { app, BrowserWindow } = require('electron');
const path = require('path');
const isDev = require('electron-is-dev');

let mainWindow;

function createWindow() {
  mainWindow = new BrowserWindow({
    width: 1400,
    height: 900,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js')
    },
    title: 'A股分析系统'
  });

  const startUrl = isDev
    ? 'http://localhost:3000'
    : `file://${path.join(__dirname, '../build/index.html')}`;
  
  mainWindow.loadURL(startUrl);

  if (isDev) {
    mainWindow.webContents.openDevTools();
  }
}

app.whenReady().then(createWindow);

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});
```

**electron/preload.js**
```javascript
const { contextBridge } = require('electron');

contextBridge.exposeInMainWorld('electronAPI', {
  isElectron: true,
  getAppVersion: () => require('../package.json').version
});
```

### 4.4 修改package.json

添加以下字段：

```json
{
  "main": "electron/main.js",
  "homepage": "./",
  "scripts": {
    "electron:dev": "concurrently \"npm start\" \"wait-on http://localhost:3000 && electron .\""
  }
}
```

### 4.5 启动开发

```bash
npm run electron:dev
```

---

## 五、环境变量配置

### backend/.env

```bash
# 现有配置...

# 新增
JWT_SECRET_KEY=your-jwt-secret-key-at-least-32-characters-long
MASTER_KEY=base64编码的32字节密钥
```

生成MASTER_KEY：
```python
import os, base64
print(base64.b64encode(os.urandom(32)).decode())
```

---

## 六、验证步骤

### 6.1 测试注册

```bash
curl -X POST http://localhost:8000/api/auth/register \
  -H "Content-Type: application/json" \
  -d '{"username": "test", "password": "test123"}'
```

### 6.2 测试登录

```bash
curl -X POST http://localhost:8000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username": "test", "password": "test123"}'
```

### 6.3 测试Electron

```bash
cd frontend-client
npm run electron:dev
```

---

## 七、下一步

完成以上步骤后，继续：

1. 实现加密网关 `/api/secure`
2. 前端添加登录页面
3. 前端改造API层使用加密通道
4. 添加离线存储
5. 添加自动更新

详见 `技术实现细节.md`
