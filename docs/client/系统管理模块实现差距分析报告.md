# 系统管理模块实现差距分析报告

> **目标**: 针对 "用户管理" 模块配置未生效（"死逻辑"）问题进行深度分析，对比设计文档与当前后端代码的实现差距。
> **状态**: 待修复
> **日期**: 2025-12-23

## 1. 核心问题概述

当前系统存在 **"配置与业务逻辑脱节"** 的严重问题。
虽然前端已经有了[系统配置]界面，且数据库 `system_configs` 表中也存储了各类安全策略，但后端核心业务逻辑（`auth.py`）**完全绕过了** 这些动态配置，使用了代码中的硬编码常量。

**导致后果**: 管理员在前端修改的密码强度、锁定策略、Token有效期等安全配置，对实际系统 **不生效**。

## 2. 详细差距分析

### 2.1 密码策略 (Password Policy)

| 配置项 | 设计要求 | 当前代码现状 (`auth.py`) | 差距 |
|:---|:---|:---|:---|
| **最小长度** | `password_min_length` (System Config) | Pydantic 模型硬编码 `min_length=6` | ❌ 无法动态调整，配置无效 |
| **复杂度检查** | `require_digit/upper/special` | **无任何验证逻辑** | ❌ 即使配置开启，注册简单密码也能通过 |
| **密码过期** | `password_expire_days` | **无检查逻辑** | ❌ 密码永久有效，过期策略未实现 |

**问题代码**:
- `auth.py` 中 `RegisterRequest` 直接使用 `min_length=6`。
- `register` 和 `change_password` 接口直接 hash 密码，未调用 `ConfigService.validate_password()`。

### 2.2 登录安全策略 (Login Policy)

| 配置项 | 设计要求 | 当前代码现状 (`auth.py`) | 差距 |
|:---|:---|:---|:---|
| **失败锁定** | 连续失败 `login_max_attempts` 次后锁定 | **未记录失败次数** | ❌ 可以无限次暴力破解 |
| **锁定时长** | 锁定 `login_lockout_minutes` 分钟 | **未检查锁定状态** | ❌ `locked_until` 字段被忽略 |
| **验证码** | 失败多次显示验证码 | **未实现** | ❌ 无验证码机制 |

**问题代码**:
- `auth.py` 的 `login` 接口在密码错误时直接抛出 401，未更新 `user.failed_attempts`。
- 登录前未检查 `user.locked_until > now()`。

### 2.3 会话管理策略 (Session Policy)

| 配置项 | 设计要求 | 当前代码现状 (`jwt_handler.py`) | 差距 |
|:---|:---|:---|:---|
| **Token有效期** | `session_access_token_hours` | 常量 `ACCESS_TOKEN_EXPIRE_HOURS = 24` | ❌ 配置修改不生效 |
| **刷新Token** | `session_refresh_token_days` | 常量 `REFRESH_TOKEN_EXPIRE_DAYS = 7` | ❌ 配置修改不生效 |
| **最大设备数** | `session_max_devices` | 读取 `user.allowed_devices` | ⚠️ 仅依赖用户字段，未关联系统全局默认值 |

**问题代码**:
- `jwt_handler.py` 定义了全局常量，生成 Token 时直接使用常量。

---

## 3. 技术债务分析

### 3.1 闲置的代码资产 (Phantom Code)
后端存在完善的配置服务逻辑，但无人调用：
- ✅ `app.services.config_service.ConfigService`: 包含了完整的策略获取和校验方法 (`get_password_policy`, `validate_password` 等)。
- ✅ `app.services.user_service.UserService`: 包含了部分操作日志逻辑。

**这就是所谓的"死逻辑"：功能写了，但没接电。**

### 3.2 缺失的拦截层
- 缺少一个统一的 `SecurityMiddleware` 或在 `auth.py` 中缺乏对 `ConfigService` 的依赖注入。

## 4. 修复建议方案

为了解决此问题，需对 `auth.py` 进行重构，接入 `ConfigService`。

### 修复步骤

1.  **接入验证逻辑**:
    - 在 `register` 和 `change_password` 接口中，移除 Pydantic 的硬编码长度限制（改为 min_length=1 基本校验），在逻辑内部调用 `ConfigService.validate_password(pass)`.

2.  **接入锁定逻辑**:
    - 修改 `login` 接口：
        - 登录前：先检查 `ConfigService.get_login_policy()` 确认是否锁定。
        - 失败时：调用 `UserService.record_login_failure()` (需在 UserService 中完善此方法，对接配置中的最大重试次数)。
        - 成功时：清零失败计数。

3.  **接入动态有效期**:
    - 修改 `jwt_handler.py` 的 `create_access_token`，接受 `expires_delta` 参数。
    - 修改 `login` 接口：调用 `ConfigService.get_session_policy()` 获取有效期配置，传给 token 生成函数。

### 预计工作量
- 后端重构: 约 4-6 小时
- 测试验证: 约 2 小时

---
*文档生成时间: 2025-12-23*
